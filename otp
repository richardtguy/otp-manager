#!/Users/richardguy/utils/otp-manager/venv/bin/python

import json
import getpass
import os
import sys
import argparse
from base64 import urlsafe_b64encode, b32decode
from time import time
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.hashes import SHA1, SHA256
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.twofactor.totp import TOTP
from cryptography.fernet import Fernet, InvalidToken
from PySide6 import QtCore, QtWidgets, QtGui

from config import KEYFILE_PATH, SALT

# path to master key file (used to persist user verification between sessions)
MASTER_KEY_PATH = sys.path[0]+'/.otp_master_key'

class OTPModel():
    """
    OTP Manager Model
    """
    def __init__(self, master_key_path, keyfile_path, salt):
        self.keyfile_path = keyfile_path
        self.master_key_path = master_key_path
        self.salt = salt
        self._master_key = self._get_master_key()

    def _get_master_key(self, password=None):
        """
        Return saved master key if available, or use password
        """
        # Retrieve key from file if available
        if password==None:
            try:
                with open(self.master_key_path, 'rb') as f:
                    master_key = f.read()
                    # Or get from user input
            except FileNotFoundError:
                return None
            return master_key
        else:
            kdf = PBKDF2HMAC(
                algorithm=SHA256(),
                length=32,
                salt=self.salt,
                iterations=100000,
                backend=default_backend()
            )
            master_key = urlsafe_b64encode(kdf.derive(password.encode()))
            # save master key to file
            with open(self.master_key_path, 'wb') as f:
                f.write(master_key)
            return master_key

    def _decrypt_otp_keys(self):
        """
        Load and decrypt account names and OTP keys from file
        """
        with open(self.keyfile_path, 'rb') as f:
            encrypted = f.read()
        master_key = self._master_key
        if master_key ==  None:
            return None
        fernet = Fernet(master_key)
        try:
            decrypted = fernet.decrypt(encrypted).decode()
        except InvalidToken:
            return None
        return json.loads(decrypted)

    @property
    def verified(self):
        self._otp_keys = self._decrypt_otp_keys()
        if self._otp_keys:
            self._verified = True
        else:
            self._verified = False
        return self._verified

    @property
    def otp_keys(self):
        if self.verified:
            return self._otp_keys
        else:
            return None

    def verify_with_password(self, password):
        self._master_key = self._get_master_key(password)

    def logout(self):
        os.remove(MASTER_KEY_PATH)

    def get_otps(self):
        otps = {}
        for account, key in self._otp_keys.items():
            missing_padding = len(key) % 8
            if missing_padding != 0:
                key += '=' * (8 - missing_padding)
            byte_key = b32decode(key, casefold=True)
            totp = TOTP(
                byte_key,
                6,
                SHA1(),
                30,
                backend=default_backend(),
                enforce_key_length=False
            )
            otp = totp.generate(time()).decode()
            otps[account] = otp
        return otps

class OTPUi(QtWidgets.QWidget):
    """
    OTP Manager GUI
    """
    def __init__(self, parent=None):
        super(OTPUi, self).__init__(parent)
        self.setWindowTitle("OTP Manager")
        self.setMinimumWidth(200)
        self._mainLayout = QtWidgets.QVBoxLayout()
        self._otpLayout = QtWidgets.QGridLayout()
        self._mainLayout.addLayout(self._otpLayout)
        self.logoutBtn = QtWidgets.QPushButton("Logout")
        self._mainLayout.addWidget(self.logoutBtn)
        self.setLayout(self._mainLayout)

    def createOTPLabels(self, data):
        """
        Create label for each account
        """
        self.labels = {}
        for account, key in data.items():
            accountLabel = QtWidgets.QLabel(account, alignment=QtCore.Qt.AlignLeft)
            otpLabel = QtWidgets.QLabel("", alignment=QtCore.Qt.AlignCenter)
            otpLabel.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
            self.labels[account] = {"accountLabel": accountLabel, "otpLabel": otpLabel}

        for n, label in enumerate(self.labels.values()):
            self._otpLayout.addWidget(label["accountLabel"], n, 0)
            self._otpLayout.addWidget(label["otpLabel"], n, 1)

    def setOTPs(self, data):
        """
        Refresh time-based one-time passwords for all accounts
        """
        for account, otp in data.items():
            self.labels[account]["otpLabel"].setText(otp)

    def getPassword(self):
        """
        Show dialog box to get password from user
        """
        text, ok = QtWidgets.QInputDialog.getText(self, "OTP Manager", "Enter password:", QtWidgets.QLineEdit.Password)
        if ok:
            return text
        else:
            return False

class OTPCtrl():
    """
    OTP Manager Controller
    """
    def __init__(self, model, view):
        self._model = model
        self._view = view
        # authenticate
        while not self._model.verified:
            self._model.verify_with_password(self._view.getPassword())
        # TODO: handle "Cancel" more elegantly
        # populate UI with initial data
        data = self._model.otp_keys
        self._view.createOTPLabels(data)
        self._updateOTPs()
        # connect timer to refresh display
        self._connectTimers()
        # connect signals and slots
        self._connectSignals()

    def _updateOTPs(self):
        otps = self._model.get_otps()
        self._view.setOTPs(otps)

    def _logout(self):
        self._model.logout()
        self._view.close()

    def _connectTimers(self):
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self._updateOTPs)
        self.timer.start(1000)

    def _connectSignals(self):
        self._view.logoutBtn.clicked.connect(self._logout)


def main(args):
    """
    Render main window
    """
    app = QtWidgets.QApplication([])
    view = OTPUi()
    view.show()
    model = OTPModel(MASTER_KEY_PATH, KEYFILE_PATH, SALT)
    controller = OTPCtrl(model=model, view=view)
    sys.exit(app.exec_())


def add_account(args):
    """
    Register a new account with a corresponding secret key for a time-based
    one-time-password (OTP).
    Spaces are removed from the key before storing, but no other validation
    is performed
    TODO: Move to GUI
    """
    try:
        data = get_otp_keys()
    except FileNotFoundError:
        print("Creating new key file...")
        data = {}
    data[args.account] = args.key.replace(" ","")
    datab = json.dumps(data).encode()
    fernet = Fernet(get_master_key())
    encrypted = fernet.encrypt(datab)
    with open(KEYFILE_PATH, 'wb') as f:
        f.write(encrypted)
    print("Added account: {}".format(args.account))

def remove_account(args):
    """
    Remove an account from the database
    TODO: Move to GUI
    """
    print("WARNING: This may be prevent you from signing in to your account!")
    if not input("Are you sure? (y/n): ").lower().strip()[:1] == "y": return
    try:
        data = get_otp_keys()
    except FileNotFoundError:
        print("ERROR: Key file missing")
        return
    try:
        del data[args.account]
    except:
        print("ERROR: Account not found")
        return
    datab = json.dumps(data).encode()
    fernet = Fernet(get_master_key())
    encrypted = fernet.encrypt(datab)
    with open(KEYFILE_PATH, 'wb') as f:
        f.write(encrypted)
    print("Deleted account: {}".format(args.account))

def export(args):
    """
    Decrypt and export OTP keys in plain text (e.g. for manually setting up
    another 2FA application. Spaces should be ignored by the other application.)
    TODO: Move to GUI
    """
    try:
        data = get_otp_keys()
    except FileNotFoundError:
        print("ERROR: Key file missing")
        return
    for account, key in sorted(data.items()):
        key_readable = ' '.join([(key[i:i+4]) for i in range(0, len(key), 4)])
        print("{:<10} {}".format(account, key_readable))


parser = argparse.ArgumentParser(description='One Time Passwords (OTP)')
parser.set_defaults(func=main)
subparsers = parser.add_subparsers()

parser_add = subparsers.add_parser('add', help='Add a new account')
parser_add.add_argument('account', help='Account name')
parser_add.add_argument('key', help='Secret key')
parser_add.set_defaults(func=add_account)

parser_remove = subparsers.add_parser('remove', help='Remove an account')
parser_remove.add_argument('account', help='Account to remove')
parser_remove.set_defaults(func=remove_account)

parser_export = subparsers.add_parser('export', help='Export OTP keys')
parser_export.set_defaults(func=export)

if __name__ == '__main__':
    args = parser.parse_args()
    args.func(args)
